module mainl where

import parse
open import lib
open import lettuce-types
import lettuce

module parsem = parse lettuce.gratr2-nt ptr
open parsem
open parsem.pnoderiv lettuce.rrs lettuce.lettuce-rtn
open import run ptr
open noderiv {- from run.agda -}

get-used : letterm â†’ ð•ƒ var
get-used l = []

get-declared : letterm â†’ ð•ƒ var
get-declared l = []

vars-to-string-h2 : ð•ƒ string â†’ string
vars-to-string-h2 [] = ""
vars-to-string-h2 (l :: ls) = "" ^ l ^ " " ^ (vars-to-string-h2 ls)

vars-to-string-h1 : trie string â†’ ð•ƒ var â†’ string â†’ trie string
vars-to-string-h1 t [] x = t
vars-to-string-h1 t (l :: ls) x = vars-to-string-h1 (trie-insert t l x) ls x

vars-to-string : ð•ƒ var â†’ string
vars-to-string vs = vars-to-string-h2 (trie-strings (vars-to-string-h1 empty-trie vs ""))

test0 : ð•ƒ var
test0 = "test" :: "cat" :: "dog" :: "do" :: "dog" :: []

process-letterm-h : trie string â†’ letterm â†’ string
process-letterm-h t (Let _ y k l) = process-letterm-h (trie-insert t y (process-letterm-h t k)) l
process-letterm-h t (Parens l) = process-letterm-h t l
process-letterm-h t (Plus k l) = process-letterm-h t k ^ process-letterm-h t l
process-letterm-h t (Var _ y) with trie-lookup t y
... | nothing = ""
... | just n = n

process-letterm : letterm â†’ string
process-letterm l = process-letterm-h empty-trie l

global-to-var : global â†’ var
global-to-var (Global var num) = var

global-to-num : global â†’ num
global-to-num (Global var num) = num

process-g-test-h : trie string â†’ globals â†’ string
process-g-test-h t GlobalsNil = ""
process-g-test-h t (GlobalsCons x g) with trie-lookup t (global-to-var x)
... | nothing = process-g-test-h (trie-insert t (global-to-var x) (global-to-num x)) g
... | just n = n


{- these functions are used for declared section -}
gs-to-var : globals â†’ ð•ƒ var
gs-to-var (GlobalsCons x g) = (global-to-var x) :: gs-to-var g
gs-to-var GlobalsNil = []

ls-to-var : letterm â†’ ð•ƒ var
ls-to-var (Let x xâ‚ l lâ‚) = xâ‚ :: ls-to-var l ++ ls-to-var lâ‚
ls-to-var (Parens l) = ls-to-var l
ls-to-var (Plus l lâ‚) = (ls-to-var l) ++ (ls-to-var lâ‚)
ls-to-var (Var x xâ‚) = []

ls-to-var1 : letterm â†’ ð•ƒ var
ls-to-var1 (Let x xâ‚ l lâ‚) = (ls-to-var1 l) ++ (ls-to-var1 lâ‚)
ls-to-var1 (Parens l) = ls-to-var1 l
ls-to-var1 (Plus l lâ‚) = (ls-to-var1 l) ++ (ls-to-var1 lâ‚)
ls-to-var1 (Var x xâ‚) = xâ‚ :: []

dec-print : globals â†’ letterm â†’ string
dec-print g l = "declared: " ^ vars-to-string ((gs-to-var g) ++ (ls-to-var l))

used-print : globals â†’ letterm â†’ string
used-print g l = "used: " ^ vars-to-string ((gs-to-var g) ++ (ls-to-var1 l))

process-start : start â†’ string
process-start (InputTerm g l) = (process-g-test-h empty-trie g) ^ dec-print g l ^ used-print g l

process : Run â†’ string
process (ParseTree (parsed-start p) :: []) = process-start p
process r = "Parsing failure (run with -" ^ "-showParsed).\n"

putStrRunIf : ð”¹ â†’ Run â†’ IO âŠ¤
putStrRunIf tt r = putStr (Run-to-string r) >> putStr "\n"
putStrRunIf ff r = return triv

processText : (showParsed : ð”¹) â†’ string â†’ IO âŠ¤
processText showParsed x with runRtn (string-to-ð•ƒchar x)
... | s with s
... | injâ‚ cs = putStr "Characters left before failure : " >> putStr (ð•ƒchar-to-string cs) >> putStr "\nCannot proceed to parsing.\n"
... | injâ‚‚ r with rewriteRun r
... | r' with putStrRunIf showParsed r'
... | sr' = sr' >> putStr (process r')

processArgs : (showParsed : ð”¹) â†’ ð•ƒ string â†’ IO âŠ¤
processArgs showParsed (input-filename :: []) = (readFiniteFile input-filename) >>= processText showParsed
processArgs showParsed ("--showParsed" :: xs) = processArgs tt xs
processArgs showParsed (x :: xs) = putStr ("Unknown option " ^ x ^ "\n")
processArgs showParsed [] = putStr "Please run with the name of a file to process.\n"

main : IO âŠ¤
main = getArgs >>= processArgs ff
